import numpy as np
# def cxPartialyMatched(ind1, ind2):
#     """Executes a partially matched crossover (PMX) on the input individuals.
#     The two individuals are modified in place. This crossover expects
#     :term:`sequence` individuals of indices, the result for any other type of
#     individuals is unpredictable.
#
#     :param ind1: The first individual participating in the crossover.
#     :param ind2: The second individual participating in the crossover.
#     :returns: A tuple of two individuals.
#     Moreover, this crossover generates two children by matching
#     pairs of values in a certain range of the two parents and swapping the values
#     of those indexes. For more details see [Goldberg1985]_.
#     This function uses the :func:`~random.randint` function from the python base
#     :mod:`random` module.
#
#     .. [Goldberg1985] Goldberg and Lingel, "Alleles, loci, and the traveling
#        salesman problem", 1985.
#     """
#     ind1 = [8, 4, 7, 3, 6, 2, 5, 1, 9, 0]
#     ind2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
#     size = min(len(ind1), len(ind2))
#     p1, p2 = [0] * size, [0] * size
#
#     # Initialize the position of each indices in the individuals
#     for i in range(size):
#         p1[ind1[i]] = i
#         p2[ind2[i]] = i
#     # Choose crossover points
#     cxpoint1 = np.random.randint(0, size)
#     cxpoint2 = np.random.randint(0, size - 1)
#     if cxpoint2 >= cxpoint1:
#         cxpoint2 += 1
#     else:  # Swap the two cx points
#         cxpoint1, cxpoint2 = cxpoint2, cxpoint1
#
#     # Apply crossover between cx points
#     for i in range(cxpoint1, cxpoint2):
#         # Keep track of the selected values
#         temp1 = ind1[i]
#         temp2 = ind2[i]
#         # Swap the matched value
#         ind1[i], ind1[p1[temp2]] = temp2, temp1
#         ind2[i], ind2[p2[temp1]] = temp1, temp2
#         # Position bookkeeping
#         p1[temp1], p1[temp2] = p1[temp2], p1[temp1]
#         p2[temp1], p2[temp2] = p2[temp2], p2[temp1]
#     print(ind1)
#     print(ind2)
#     return ind1, ind2
#
# def pmx(a,b, start, stop):
# child = [None]*len(a)
# # Copy a slice from first parent:
# child[start:stop] = a[start:stop]
# # Map the same slice in parent b to child using indices from parent a:
# for ind,x in enumerate(b[start:stop]):
# ind += start
# if x not in child:
# while child[ind] != None:
# ind = b.index(a[ind])
# child[ind] = x
# # Copy over the rest from parent b
# for ind,x in enumerate(child):
# if x == None:
# child[ind] = b[ind]
# return child

def pmx_crossover(ind1, ind2):
    ind1 = [8, 4, 7, 3, 6, 2, 5, 1, 9, 0]
    ind2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    size = len(ind1)
    cxpoint1 = np.random.randint(1, size)
    cxpoint2 = np.random.randint(1, size - 1)
    if cxpoint2 >= cxpoint1:
        cxpoint2 += 1
    else:  # Swap the two cx points
        cxpoint1, cxpoint2 = cxpoint2, cxpoint1

    child1_genotype = [None] * size
    child2_genotype = [None] * size

    # Copy a slice from first parent
    child1_genotype[cxpoint1:cxpoint2] = ind1[cxpoint1:cxpoint2].copy()
    child2_genotype[cxpoint1:cxpoint2] = ind2[cxpoint1:cxpoint2].copy()

    # Map the same slice in second parent to child using indices from first parent
    for ind, x in enumerate(ind2[cxpoint1:cxpoint2]):
        ind += cxpoint1
        if x not in child1_genotype:
            while child1_genotype[ind] != None:
                ind = ind2.index(ind1[ind])
                child1_genotype[ind] = x

    for i, x in enumerate(ind1[cxpoint1:cxpoint2]):
        i += cxpoint1
        if x not in child2_genotype:
            while child2_genotype[i] != None:
                ind = ind1.index(ind2[i])
                child2_genotype[i] = x

    # Copy over the rest from the second parent
    for ind, x in enumerate(child1_genotype):
        if x == None:
            child1_genotype = ind2[ind]

    for i, x in enumerate(child2_genotype):
        if x == None:
            child2_genotype = ind1[i]

    print(child1_genotype)
    print(child2_genotype)
    return child1_genotype, child2_genotype

pmx_crossover([8, 4, 7, 3, 6, 2, 5, 1, 9, 0],[0, 1, 2, 3, 4, 5, 6, 7, 8, 9])